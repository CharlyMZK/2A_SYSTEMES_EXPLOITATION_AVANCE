/**
 * \file skeleton.c
 * \brief Basic parsing options skeleton.
 * \author Pierre L. <pierre1.leroy@orange.com>
 * \version 0.1
 * \date 10 septembre 2016
 *
 * Basic parsing options skeleton exemple c file.
 */
 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<errno.h>
 #include <fcntl.h> // for open
 #include <unistd.h> // for close
 #include<getopt.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <time.h>
 #include <dirent.h>
 #include <wait.h>
 #include <unistd.h>
 #include <pthread.h>
 #define STDOUT 1
 #define STDERR 2

 #define MAX_PATH_LENGTH 4096
 #define USAGE_SYNTAX "[OPTIONS] -i INPUT -o OUTPUT"
 #define USAGE_PARAMS "OPTIONS:\n\
   -i, --input  INPUT_FILE  : input file\n\
   -o, --output OUTPUT_FILE : output file\n\
 ***\n\
   -v, --verbose : enable *verbose* mode\n\
   -h, --help    : display this help\n\
 "

 typedef struct
 {
    int minValue;
    pthread_mutex_t mutex_min;
 }
 min_t;
  
 static min_t minResearch =
 {
    .minValue = 0,
    .mutex_min = PTHREAD_MUTEX_INITIALIZER,
 };
 
 typedef struct
 {
    int maxValue;
    pthread_mutex_t mutex_max;
 }
 max_t;
  
 static max_t maxResearch =
 {
    .maxValue = 0,
    .mutex_max = PTHREAD_MUTEX_INITIALIZER,
 };

 
struct arguments {
  int size;
  int * array;
};

 /**
  * Procedure which displays binary usage
  * by printing on stdout all available options
  *
  * \return void
  */
 void print_usage(char* bin_name)
 {
   dprintf(1, "USAGE: %s %s\n\n%s\n", bin_name, USAGE_SYNTAX, USAGE_PARAMS);
 }


 /**
  * Procedure checks if variable must be free
  * (check: ptr != NULL)
  *
  * \param void* to_free pointer to an allocated mem
  * \see man 3 free
  * \return void
  */
 void free_if_needed(void* to_free)
 {
   if (to_free != NULL) free(to_free);
 }


 /**
  *
  * \see man 3 strndup
  * \see man 3 perror
  * \return
  */
 char* dup_optarg_str()
 {
   char* str = NULL;

   if (optarg != NULL)
   {
     str = strndup(optarg, MAX_PATH_LENGTH);

     // Checking if ERRNO is set
     if (str == NULL)
       perror(strerror(errno));
   }

   return str;
 }

 /**
  * Binary options string
  * (linked to optionn declaration)
  *
  * \see man 3 getopt_long or getopt
  */
 const char* binary_optstr = "hvi:o:";


 void checkIfHasArgs(int argc)
 {
   if(argc <=1)
   {
     printf("Pas de paramètre \n");
     exit(0);
     //perror(strerror(errno));

   }
 }

 //Génère un tableau de taille size remplis avec des entier aléatoires
int * generateArray(int size)
{
  int * array = malloc(size * sizeof(int));
  srand(time(NULL)); // initialisation de rand
  for(int i =0; i<size;i++)
  {
    array[i] = rand()%1000;
  }
  return array;
}

void printArray(int size, int * array)
{
  for(int i =0; i<size;i++)
  {
    printf("%d ;",array[i]);
  }
  printf("\n");
}



void* getMin(int size, int * array){
  int min = array[0];
  for(int i =1; i<size;i++)
  {
      if(array[i] < min){
        min = array[i];
      }
  }
  return (void*) min;
}

void* getMax(int size, int * array){
  int max = array[0];
  for(int i =1; i<size;i++)
  {
      if(array[i] > max){
        max = array[i];
      }
  }
  return (void*) max;
}



void* getMinThread(void * args){
  struct arguments * structArguments = args;
  int size = structArguments->size;
  int * array = structArguments->array;
  int min = array[0];
  for(int i = 1; i < size; i++)
  {
    if(array[i] < min)
      min = array[i];
  }

  pthread_mutex_lock (&minResearch.mutex_min);
  if(min < minResearch.minValue){
    minResearch.minValue = min;
  }
  pthread_mutex_unlock (&minResearch.mutex_min);
  //printf("[Thread] Min executé, j'ai trouvé : %d\n",min);
  return (void *) min;
}

void* getMaxThread(void * args){
  struct arguments * structArguments = args;
  int size = structArguments->size;
  int * array = structArguments->array;
  int max = array[0];
  for(int i =1; i<size;i++)
  {
      if(array[i] > max){
        max = array[i];
      }
  }
  pthread_mutex_lock (&maxResearch.mutex_max);
  if(max > maxResearch.maxValue){
    maxResearch.maxValue = max;
  }
  pthread_mutex_unlock (&maxResearch.mutex_max);
  //printf("[Thread] Max executé, j'ai trouvé : %d\n",max);
  return (void *) max;
}





 /**
  * Binary main loop
  *
  * \return 1 if it exit successfully
  */
 int main(int argc, char** argv)
 {
  int sizeArray = 10;
  int* randomArray = generateArray(sizeArray);
  minResearch.minValue = randomArray[0];
  maxResearch.maxValue = randomArray[0];
  struct timeval temps_avant_sans_thread, temps_apres_sans_thread, temps_avant_avec_thread, temps_apres_avec_thread;

  printf("\n[ EXECUTION AVEC THREAD ]\n"); 
  gettimeofday (&temps_avant_avec_thread, NULL);
  pthread_t threadArrayMinResearch[10];
  pthread_t threadArrayMaxResearch[10];
  struct arguments * argumentsArray[10];
  for(int i = 0;i < 10;i++)
  {
      struct arguments * args = malloc(sizeof(struct arguments));
      argumentsArray[i] = args;
      args->size = sizeArray/10;
      args->array = randomArray + (args->size)*i;
      pthread_create(&(threadArrayMinResearch[i]),NULL,&getMinThread,(void *)args);
      pthread_create(&(threadArrayMaxResearch[i]),NULL,&getMaxThread,(void *)args);
  }

  int min = randomArray[0];
  for(int i = 0; i< 10;i++)
  {
    void * resThread;
    pthread_join(threadArrayMinResearch[i],&resThread);
    if((int)resThread < min)
      min = (int)resThread;
    free(argumentsArray[i]);
  }

  int max = randomArray[0];
  for(int i = 0; i< 10;i++)
  {
    void * resThread;
    pthread_join(threadArrayMaxResearch[i],&resThread);
    if((int)resThread > max)
    max = (int)resThread;
    free(argumentsArray[i]);
  }

  printf("\nRecherche du minimum dans une variable locale ( sans mutex ) : %d\n",(int)min);
  printf("Recherche du minimum dans une variable globale ( avec mutex ) : %d\n", minResearch.minValue);
  printf("\nRecherche du maximum dans une variable locale ( sans mutex ) : %d\n",(int)max);
  printf("Recherche du maximum dans une variable globale ( avec mutex ) : %d\n", maxResearch.maxValue);
  gettimeofday (&temps_apres_avec_thread, NULL);
  printf("\nTemps écoulé : %ld s\n", ((temps_apres_avec_thread.tv_sec - temps_avant_avec_thread.tv_sec) * 1000000 + temps_apres_avec_thread.tv_usec) - temps_avant_avec_thread.tv_usec);
  printf("\n[ EXECUTION SANS THREAD ]\n"); 
  gettimeofday (&temps_avant_sans_thread, NULL);
  printf("\nRecherche du min, sa valeur est : %d\n",(int) getMin(sizeArray,randomArray));
  printf("Recherche du max, sa valeur est :  %d\n",(int) getMax(sizeArray,randomArray));
  gettimeofday (&temps_apres_sans_thread, NULL);
  printf("\nTemps écoulé : %ld s\n", ((temps_apres_sans_thread.tv_sec - temps_avant_sans_thread.tv_sec) * 1000000 + temps_apres_sans_thread.tv_usec) - temps_avant_sans_thread.tv_usec);
 }

 //Ne compile pas, manque -lpthread
