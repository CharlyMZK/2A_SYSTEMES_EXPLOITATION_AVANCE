/**
 * \file skeleton.c
 * \brief Basic parsing options skeleton.
 * \author Pierre L. <pierre1.leroy@orange.com>
 * \version 0.1
 * \date 10 septembre 2016
 *
 * Basic parsing options skeleton exemple c file.
 */
 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<errno.h>
 #include <fcntl.h> // for open
 #include <unistd.h> // for close
 #include<getopt.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <time.h>
 #include <dirent.h> 
 #include <wait.h>
 #include <unistd.h>
 #define STDOUT 1
 #define STDERR 2
 
 #define MAX_PATH_LENGTH 4096
 
 
 #define USAGE_SYNTAX "[OPTIONS] -i INPUT -o OUTPUT"
 #define USAGE_PARAMS "OPTIONS:\n\
   -i, --input  INPUT_FILE  : input file\n\
   -o, --output OUTPUT_FILE : output file\n\
 ***\n\
   -v, --verbose : enable *verbose* mode\n\
   -h, --help    : display this help\n\
 "
 
 /**
  * Procedure which displays binary usage
  * by printing on stdout all available options
  *
  * \return void
  */
 void print_usage(char* bin_name)
 {
   dprintf(1, "USAGE: %s %s\n\n%s\n", bin_name, USAGE_SYNTAX, USAGE_PARAMS);
 }
 
 
 /**
  * Procedure checks if variable must be free
  * (check: ptr != NULL)
  *
  * \param void* to_free pointer to an allocated mem
  * \see man 3 free
  * \return void
  */
 void free_if_needed(void* to_free)
 {
   if (to_free != NULL) free(to_free);  
 }
 
 
 /**
  *
  * \see man 3 strndup
  * \see man 3 perror
  * \return
  */
 char* dup_optarg_str()
 {
   char* str = NULL;
 
   if (optarg != NULL)
   {
     str = strndup(optarg, MAX_PATH_LENGTH);
     
     // Checking if ERRNO is set
     if (str == NULL) 
       perror(strerror(errno));
   }
 
   return str;
 }
 
 /**
  * Binary options string
  * (linked to optionn declaration)
  *
  * \see man 3 getopt_long or getopt
  */ 
 const char* binary_optstr = "hvi:o:";
 
 
 void checkIfHasArgs(int argc)
 {
   if(argc <=1)
   {
     printf("Pas de paramètre \n");
     exit(0);
     //perror(strerror(errno));
     
   }
 }
 
 //Génère un tableau de taille size remplis avec des entier aléatoires
int * generateArray(int size)
{
  int * array = malloc(size * sizeof(int));
  srand(time(NULL)); // initialisation de rand
  for(int i =0; i<size;i++)
  {
    array[i] = rand()%1000;
  }
  return array;
}

void printArray(int size, int * array)
{
  for(int i =0; i<size;i++)
  {
    printf("%d ;",array[i]);
  }
  printf("\n");
}

void* getMin(int size, int * array){
  int min = array[0];
  for(int i =1; i<size;i++)
  {
      if(array[i] < min){
        min = array[i];
      }
  }
  return (void*) min;
}

void* getMax(int size, int * array){
  int max = array[0];
  for(int i =1; i<size;i++)
  {
      if(array[i] > max){
        max = array[i];
      }
  }
  return (void*) max;
}

 /**
  * Binary main loop
  *
  * \return 1 if it exit successfully 
  */
 int main(int argc, char** argv)
 {
  int* randomArray = generateArray(100);
  struct timeval temps_avant, temps_apres;
  printArray(100,randomArray);
  gettimeofday (&temps_avant, NULL);
  printf("\n Le minimum est : %d\n",(int) getMin(100,randomArray));
  printf("\n Le maximum est : %d\n",(int) getMax(100,randomArray));
  gettimeofday (&temps_apres, NULL);
  printf("temps écoulé : %ld s\n", ((temps_apres.tv_sec - temps_avant.tv_sec) * 1000000 + temps_apres.tv_usec) - temps_avant.tv_usec);
 }
 