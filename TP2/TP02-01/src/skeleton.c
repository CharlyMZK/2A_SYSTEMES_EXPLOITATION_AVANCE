/**
 * \file skeleton.c
 * \brief Basic parsing options skeleton.
 * \author Pierre L. <pierre1.leroy@orange.com>
 * \version 0.1
 * \date 10 septembre 2016
 *
 * Basic parsing options skeleton exemple c file.
 */
 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<errno.h>
 #include <fcntl.h> // for open
 #include <unistd.h> // for close
 #include<getopt.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <dirent.h> 
 #include <wait.h>
 #include <unistd.h>
 #define STDOUT 1
 #define STDERR 2
 
 #define MAX_PATH_LENGTH 4096
 
 
 #define USAGE_SYNTAX "[OPTIONS] -i INPUT -o OUTPUT"
 #define USAGE_PARAMS "OPTIONS:\n\
   -i, --input  INPUT_FILE  : input file\n\
   -o, --output OUTPUT_FILE : output file\n\
 ***\n\
   -v, --verbose : enable *verbose* mode\n\
   -h, --help    : display this help\n\
 "
 
 /**
  * Procedure which displays binary usage
  * by printing on stdout all available options
  *
  * \return void
  */
 void print_usage(char* bin_name)
 {
   dprintf(1, "USAGE: %s %s\n\n%s\n", bin_name, USAGE_SYNTAX, USAGE_PARAMS);
 }
 
 
 /**
  * Procedure checks if variable must be free
  * (check: ptr != NULL)
  *
  * \param void* to_free pointer to an allocated mem
  * \see man 3 free
  * \return void
  */
 void free_if_needed(void* to_free)
 {
   if (to_free != NULL) free(to_free);  
 }
 
 
 /**
  *
  * \see man 3 strndup
  * \see man 3 perror
  * \return
  */
 char* dup_optarg_str()
 {
   char* str = NULL;
 
   if (optarg != NULL)
   {
     str = strndup(optarg, MAX_PATH_LENGTH);
     
     // Checking if ERRNO is set
     if (str == NULL) 
       perror(strerror(errno));
   }
 
   return str;
 }
 
 /**
  * Binary options string
  * (linked to optionn declaration)
  *
  * \see man 3 getopt_long or getopt
  */ 
 const char* binary_optstr = "hvi:o:";
 
 
 void checkIfHasArgs(int argc)
 {
   if(argc <=1)
   {
     printf("Pas de paramètre \n");
     exit(0);
     //perror(strerror(errno));
     
   }
 }
 
 /**
  * Binary main loop
  *
  * \return 1 if it exit successfully 
  */
 int main(int argc, char** argv)
 {
   checkIfHasArgs(argc);
   printf("%s \n",argv[1]);
 
   int f = fork();
   //Fils
   if(f == 0)
   {
     printf("Fils - PID : '%d' PID du père : '%d'\n", getpid(),getppid());
     //Non obligatoire, seulement utilise si on veux réouvrir 1
     //int copyFdPrint = dup(1);
 
     close(1);
     //Réouverture de 1 si besoin
     //dup2(copyFdPrint, 1);
 
     //Ouverture du fichier en lecture ecriture
     char * path = "./tmpFileSystem-XXXXXX";
     int filedes = open(path, O_RDWR | O_CREAT);
     //Remplacement de la sortie standart par le descripteur de fichier
     dup2(filedes, 1);
     //Ecriture dans le fichier
     printf("file descriptor : %d \n", filedes);
     //Execution de la commande passé en paramètre
     //LE deuxième paramètre, corespondant à argv[0], ne peux pas être NULL
      execl(argv[1],"", NULL);
   }
   //Père
   else
   {
     int status;
     printf("Père - PID : '%d' PID du fils : '%d', Status du fils %d\n", getpid(),f,status);
     wait(&status);
     printf("Fin du père \n");
 
   } 
 
   return EXIT_SUCCESS;
 }
 